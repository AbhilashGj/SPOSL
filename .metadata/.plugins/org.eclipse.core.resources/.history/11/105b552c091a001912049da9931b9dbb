import java.io.BufferedReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
import java.util.Map.Entry;

import javax.crypto.Mac;
import javax.crypto.MacSpi;

class Triplet{
	// To store MNT macro name, number of parameters and line number
	public String name;
	public Integer args, line;
	
	public Triplet(String s, Integer a, Integer l){
		name = s;
		args = a;
		line = l;
	}
	
	public void print(){
		System.out.println("Name: "+name+"\tArgs:"+args+"\tline:"+line+"\n");
	}
	
}

class Arguments{
	// For actual vs positional and actual vs formal parameters
	// Create object for each macro
	HashMap<String, Integer> avsp;
	HashMap<String, Integer> fvsp;
	
	public Arguments(){
		avsp = new HashMap<String, Integer>();
		fvsp = new HashMap<String, Integer>();
	}
	
	public HashMap<String, Integer> ret_avsp(){
		return avsp;
	}
	
	
	
}

public class MacroPass1 {
	
	// Main class to parse the macros
	
	Hashtable<Integer, String> MDT;
	ArrayList<Triplet> MNT;
	int lc;
	
	public MacroPass1(){
		MDT = new Hashtable<Integer, String>();
		MNT = new ArrayList<Triplet>();
		lc = 0;
	}
	
	public void print(Object o){ System.out.println(o); }
	
	public void print_tables() {
		// Print MNT
		print("\n\tMNT\n");
		for(Triplet tr: MNT){
			tr.print();
		}
		
		// Print MDT
		print("\n\tMDT\n");
		for(Entry<Integer, String> entry: MDT.entrySet()){
			print(entry.getKey() + " : " + entry.getValue() + "\n");
		}
	}
	
	public void parse_file(BufferedReader br) throws Exception{
		// Main file parser and write the intermediate code in other file
		
		//TODO: To write to a intermediate file
		HashMap<String, Arguments> arg_list = new HashMap<String, Arguments>();
		PrintWriter pr = new PrintWriter("inter_macro", "utf-8");
		boolean macro_flag = false;
		String line;
		String current_macro_name = null;
		
		while((line = br.readLine()) != null){
			
			String words[] = line.split("\t");
			
			// If macro keyword is detected
			if(words[1].equalsIgnoreCase("MACRO")){
				
				// Set the macro_flag true and set the current macro name
				macro_flag = true;
				current_macro_name = words[1];
				
				//Create an object of actual vs positional parameters and add it to arg_list
				Arguments ar = new Arguments();
				int parameters = 0;
				for(int i = 3;i < words.length; i++){
					ar.avsp.put(words[i], i-2);
					parameters += 1;
				}
				arg_list.put(words[1], ar);
				
				//Create a Triplet and Add name and parameters and line number to MNT
				int line_no = 0;
				if(!MDT.isEmpty()){
					line_no = MDT.size();
				}
				Triplet tr = new Triplet(words[1], new Integer(parameters), new Integer(line_no));
				MNT.add(tr);
				
			}
			
			// If macro flag is set, means we are inside the macro
			if(macro_flag){
				
				//If MEND occurs then write it to MDT and reset macro_flag
				if(words[1].equalsIgnoreCase("MEND")){
					MDT.put(lc, words[1]);
					macro_flag = false;
				}
				
				//If general instruction occurs then replace the actual arguments
				// with formal arguments
				else{
					
					// Get the actual vs formal arguments table for current macro
					HashMap<String, Integer> cur_avsp = arg_list.get(current_macro_name).ret_avsp();
					
					//Loop through the avsp to replace each actual argument with positional argument
					for (Entry<String, Integer> entry : cur_avsp.entrySet()) {
					    // Replace all occurrences of actual to positional
						line.replaceAll(entry.getKey(), Integer.toString(entry.getValue()));
					}
					
					//write the line in the MDT
					MDT.put(lc, line);
				}
				
			}
			
			// If we are not inside a macro
			if(!macro_flag){
				print(line);
			}
			// If 
			
			// Increment the line counter
			lc += 1;
		}
		
	}
	
	public static void main(String args[]){
		
		MacroPass1 mp = new MacroPass1();
		mp.parse_file(new BufferedReader(new FileReader("macro")));
	}
}
